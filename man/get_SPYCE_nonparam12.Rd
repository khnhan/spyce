% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_SPYCE_nonparam12.R
\name{get_SPYCE_nonparam12}
\alias{get_SPYCE_nonparam12}
\title{SPYCE for (beta, sigma) with nonparametrically estimated \eqn{f_{X\mid Z}} and \eqn{f_{C\mid Y,Z}}}
\usage{
get_SPYCE_nonparam12(
  y_data,
  w_data,
  delta_data,
  z_data = NULL,
  surv_c_vals,
  surv_x_vals,
  init,
  sigma_fixed = NULL,
  tt = 20,
  m = 20,
  h3,
  nleqslv_args = list()
)
}
\arguments{
\item{y_data}{Numeric vector.}

\item{w_data}{Numeric vector of \eqn{W=\min(X,C)}.}

\item{delta_data}{Logical or \{0,1\} vector: \eqn{\Delta=1\{X \le C\}}.}

\item{z_data}{Optional numeric vector (binary \{0,1\}); if provided, must match length of \code{y_data}.}

\item{surv_c_vals}{Numeric vector, length \code{length(y_data)}: conditional survival
\eqn{S_{C\mid Y,Z}(W_i\mid Y_i,Z_i)} (or \eqn{S_{C\mid Y}(W_i\mid Y_i)}) at each observation.}

\item{surv_x_vals}{Numeric vector, length \code{length(y_data)}: conditional survival
\eqn{S_{X\mid Y,Z}(W_i\mid Y_i,Z_i)} (or \eqn{S_{X\mid Y}(W_i\mid Y_i)}) at each observation.}

\item{init}{Numeric vector of free parameters:
\itemize{
\item Case A: \code{c(beta0,beta1,beta2,beta3, sigma)}
\item Case B: \code{c(beta0,beta1, sigma)}
\item Case C: \code{c(beta0,beta1,beta2,beta3)}
\item Case D: \code{c(beta0,beta1)}
}}

\item{sigma_fixed}{Optional positive scalar; if supplied, \eqn{\sigma} is treated as known.}

\item{tt}{Number of grid points where the integral is computed; defaults to 20.}

\item{m}{Number of grid points over \code{[min(w_data), max(w_data)]} to solve the Fredholm equation; default 20.}

\item{h3}{Positive bandwidth used for kernel weighting for \eqn{Y} variable.}

\item{nleqslv_args}{Named list of extra args passed to \code{nleqslv::nleqslv()}.}
}
\value{
list with \code{$beta_SPYCE_nonparam12}, \code{$sigma_SPYCE_nonparam12}, \code{$root}.
}
\description{
Solves the efficient estimating equation
\deqn{\sum_{i=1}^n S_{\mathrm{eff}}(Y_i,W_i,\Delta_i,Z_i;\theta)=0}
via \code{nleqslv}, where the efficient score uses kernel-based components.
This nonparametric version expects survival weights for both \eqn{C\mid Y,Z} (or \eqn{C\mid Y})
and \eqn{X\mid Y,Z} (or \eqn{X\mid Y}) supplied as \code{surv_c_vals} and \code{surv_x_vals}.

Supported modes:
\itemize{
\item (A) estimate \eqn{(\beta,\sigma)} with \code{z_data}
\item (B) estimate \eqn{(\beta,\sigma)} without \code{z_data}
\item (C) estimate \eqn{\beta} with \code{z_data} and fixed \code{sigma}
\item (D) estimate \eqn{\beta} without \code{z_data} and fixed \code{sigma}
}
}
\examples{
library(truncnorm)
set.seed(1)
n = 500; beta = c(0, 3); sigma = 4
# Data generation
# Y|X ~ N(beta_0 + beta_1 X, 1)
x_data = rtruncnorm(n, a = -1, b = 1, mean = 0, sd = 1)
y_data = cbind(1,x_data) \%*\% beta + sigma * rnorm(n)
c_data = rtruncnorm(n, a = -1, b = 1, mean = 0, sd = 1)
z_data = rbinom(n, size = 1, prob = 0.6)
# Generate W and Delta from X and C
w_data = pmin(c_data,x_data)
delta_data = as.numeric(x_data<=c_data)
# Compute survival function
kern_gaussian = function(cond, cond_data, h = sd(cond_data)){ #Gaussian kernel
  exp(- 0.5 * apply(as.matrix(cond_data), 1, function(x) sum((cond - x)^2)) / h^2) / (sqrt(2*pi)*h)
}
surv_c_vals = sapply(1:n, function(i){
  conditional_Kaplan_Meier(w_data[i], w_data, 1-delta_data,
                           z_c = y_data[i], z_c_data = y_data,
                           z_d = z_data[i], z_d_data = z_data,
                           kern = kern_gaussian)})
surv_x_vals = sapply(1:n, function(i){
  conditional_Kaplan_Meier(w_data[i], w_data, delta_data,
                           z_c = y_data[i], z_c_data = y_data,
                           z_d = z_data[i], z_d_data = z_data,
                           kern = kern_gaussian)})
surv_c_vals_nz = sapply(1:n, function(i){
  conditional_Kaplan_Meier(w_data[i], w_data, 1-delta_data,
                           z_c = y_data[i], z_c_data = y_data,
                           kern = kern_gaussian)})
surv_x_vals_nz = sapply(1:n, function(i){
  conditional_Kaplan_Meier(w_data[i], w_data, delta_data,
                           z_c = y_data[i], z_c_data = y_data,
                           kern = kern_gaussian)})
# CASE A: true = (0, 3, 0, 0, 4)
get_SPYCE_nonparam12(y_data,
                     w_data,
                     delta_data,
                     z_data,
                     surv_c_vals = surv_c_vals,
                     surv_x_vals = surv_x_vals,
                     init = c(0.5, 2.5, 0.1, 0.1, 3.5),
                     h3 = 3*sd(y_data),
                     nleqslv_args = list())
# CASE B: true = (0, 3, 4)
get_SPYCE_nonparam12(y_data,
                     w_data,
                     delta_data,
                     surv_c_vals = surv_c_vals_nz,
                     surv_x_vals = surv_x_vals_nz,
                     init = c(0.5, 2.5, 3.5),
                     h3 = 3*sd(y_data),
                     nleqslv_args = list())
# CASE C: true = (0, 3, 0, 0)
get_SPYCE_nonparam12(y_data,
                     w_data,
                     delta_data,
                     z_data,
                     surv_c_vals = surv_c_vals,
                     surv_x_vals = surv_x_vals,
                     init = c(0.5, 2.5, 0.1, 0.1),
                     sigma_fixed = 4,
                     h3 = 3*sd(y_data),
                     nleqslv_args = list())
# CASE D: true = (0, 3)
get_SPYCE_nonparam12(y_data,
                     w_data,
                     delta_data,
                     surv_c_vals = surv_c_vals_nz,
                     surv_x_vals = surv_x_vals_nz,
                     init = c(0.5, 2.5),
                     sigma_fixed = 4,
                     h3 = 3*sd(y_data),
                     nleqslv_args = list())
}
