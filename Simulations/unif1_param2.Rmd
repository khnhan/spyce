---
title: "Censored Covariates Simulation"
author: "Kihyun Han"
date: "6/25/2024"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,  warrning = F, message = F)
```

# Setting 1
```{r}
# Checking packages installation
if(!require(MASS)){
  install.packages("MASS",repos = "http://cran.us.r-project.org")
  library(MASS)
}
if(!require(foreach)){
  install.packages("foreach",repos = "http://cran.us.r-project.org")
  library(foreach)
}
if(!require(doParallel)){
  install.packages("doParallel",repos = "http://cran.us.r-project.org")
  library(doParallel)
}
if(!require(gaussquad)){
  install.packages("gaussquad",repos = "http://cran.us.r-project.org")
  library(gaussquad)
}
if(!require(pracma)){
  install.packages("pracma",repos = "http://cran.us.r-project.org")
  library(pracma)
}
if(!require(truncnorm)){
  install.packages("truncnorm",repos = "http://cran.us.r-project.org")
  library(truncnorm)
}
if(!require(rootSolve)){
  install.packages("rootSolve",repos = "http://cran.us.r-project.org")
  library(rootSolve)
}
if(!require(nleqslv)){
  install.packages("nleqslv",repos = "http://cran.us.r-project.org")
  library(nleqslv)
}
if(!require(tictoc)){
  install.packages("tictoc",repos = "http://cran.us.r-project.org")
  library(tictoc)
}
if(!require(doSNOW)){
  install.packages("doSNOW",repos = "http://cran.us.r-project.org")
  library(doSNOW)
}
```

## Data generating process
```{r}
# Data generating process
n = 1000
d = 1
#alpha1
alpha1 = 0
tau1 = 1
#beta
beta = c(0, 3)
sigma = 4
#alpha2
tau2 = 1
```

```{r}
# Data generating process
data_generating = function(k, n, d, beta, alpha1, alpha2,
                           sigma = 4, tau1 = 1, tau2 = 1){
  set.seed(k)
  # X|Z ~ N(alpha1, 1) truncated in [-1,1]
  x_data = rtruncnorm(n, 
                      a = -1, 
                      b = 1, 
                      mean = alpha1,
                      sd = tau1)
  # Y|X ~ N(beta_0 + beta_1 X, 4)
  trunc_norm = rtruncnorm(n, 
                          a = -3, 
                          b = 3, 
                          mean = 0,
                          sd = 1)
  y_data = cbind(1,x_data) %*% beta + sigma * trunc_norm
  # C|Y ~ N(alpha2_0 + alpha2_1 Y,1)
  c_data = rtruncnorm(n, 
                      a = -1, 
                      b = 1, 
                      mean = cbind(1,y_data) %*% alpha2,
                      sd = tau2)
  # generate W and Delta
  w_data = pmin(c_data, x_data)
  delta_data = as.numeric(x_data<=c_data)
  # calculate the censoring rate
  cens_rate = sum(c_data<=x_data)/n
  list(x_data = x_data,
       y_data = y_data,
       c_data = c_data,
       w_data = w_data,
       delta_data = delta_data,
       cens_rate = cens_rate)
}
```


# Define score function

```{r}
# Define score function
S_beta_f = function(beta, y, x, sigma = 4){
  res = y - (beta[1] + beta[2]*x)
  res * c(1,x) / sigma^2
}
S_beta_f = Vectorize(S_beta_f, vectorize.args = 'x')
```



```{r}
S_beta = function(beta, y, w, delta, alpha1_star,
                  sigma = 4, tau1 = 1){
  #E[I(X>W)S_beta_f(Y,X,Z) | W,Y,Z] / E[I(X>W) | W,Y,Z]
  v_x = 1/(beta[2]^2 / sigma^2 + 1/tau1^2)
  eta_x = v_x * (beta[2] * (y - beta[1]) / sigma^2
                 + alpha1_star / tau1^2)
  if(delta==0){
    if(w>1){
      S_beta_f(beta, y, w, sigma) # Any value possible
    } else{ #Middle part: integration
      x_norm = (seq(w, 1, length.out = 20) - eta_x) / sqrt(v_x)
      by = x_norm[2] - x_norm[1]
      d = dnorm(x_norm)
      num = S_beta_f(beta, y, x_norm*sqrt(v_x)+eta_x, sigma) %*% d
      denom = sum(d)
      num / denom
    }
  }else{
    S_beta_f(beta, y, w, sigma)
  }
}

S_beta_unif1 = function(beta, y, w, delta,
                        sigma = 4){
  #E[I(X>W)S_beta_f(Y,X,Z) | W,Y,Z] / E[I(X>W) | W,Y,Z]
  v_x = 1/(beta[2]^2 / sigma^2)
  eta_x = v_x * (beta[2] * (y - beta[1]) / sigma^2)
  if(delta==0){
    if(w>1){
      S_beta_f(beta, y, w, sigma) # Any value possible
    } else{ #Middle part: integration
      x_norm = (seq(w, 1, length.out = 20) - eta_x) / sqrt(v_x)
      by = x_norm[2] - x_norm[1]
      d = dnorm(x_norm)
      num = S_beta_f(beta, y, x_norm*sqrt(v_x)+eta_x, sigma) %*% d
      denom = sum(d)
      num / denom
    }
  }else{
    S_beta_f(beta, y, w, sigma)
  }
}

```

```{r}
gauss = function(tt, len = 3){
  grid = seq(-len, len, length.out = tt)
  d = dnorm(grid)
  list(x = grid,
       w = d / sum(d))
}
```

```{r}
# b_xz function will e evaluated on grid x_a
b_xz_gauss_unif1_param2 = function(beta, x_a,
                                   alpha2_star,
                                   sigma = 4, tau2 = 1,
                                   tt = 20){
  cc = gauss(tt)
  len = 20
  # temp2: E2[I(X<C) | Y,X,Z]S_beta(Y,X,Z) + E2[I(X>C)S_beta(Y,C,Z)| Y,X,Z]
  temp2 = function(x, y){
    if(x < -1){
      S_beta_f(beta, y, x, sigma)
    }else{
      c_grid = seq(-1, min(x, 1),
                   length.out = len)
      dens_c = dtruncnorm(c_grid, 
                          a = -1, 
                          b = 1, 
                          mean = sum(c(1,y) * alpha2_star),
                          sd = tau2)
      Sbeta = sapply(c_grid, function(w) 
        S_beta_unif1(beta, y, w, 0, sigma))
      Sbeta[, c(1,len)] = Sbeta[, c(1,len)] / 2
      by = c_grid[2] - c_grid[1]
      return(S_beta_f(beta, y, x, sigma) *
               (1 - ptruncnorm(x,  
                               a = -1, 
                               b = 1, 
                               mean = sum(c(1,y) * alpha2_star),
                               sd = tau2)) +
               Sbeta %*% dens_c * by)
    }
  }
  
  # # temp3: E[temp2(Y,X,Z)| X,Z]
  temp3 = function(x){
    sapply(sigma * cc$x + sum(c(1, x) * beta),
           function(y_norm)
             temp2(x, y_norm)) %*% cc$w
  }
  temp3 = Vectorize(temp3, vectorize.args = 'x')
  return(temp3(x_a))
}
```




```{r}
L_xz_gauss_unif1_param2 = function(beta, x_a,
                                   alpha2_star,
                                   sigma = 4, tau2 = 1,
                                   tt = 20){
  cc = gauss(tt)
  #temp[a(X,Z)] =  E[I(X>C)a(X,Z)|C,Y,Z] / E[I(X>C)|C,Y,Z]
  temp = function(x_a, c, y){
    v_x = 1/(beta[2]^2 / sigma^2)
    eta_x = v_x * (beta[2] * (y - beta[1]) / sigma^2)
    # p: discretization of f(x|y,z) on x_a
    p = dtruncnorm(x_a,  
                   a = -1, 
                   b = 1, 
                   mean = eta_x,
                   sd = sqrt(v_x))
    num = (x_a > c) * p
    denom = sum(num)
    ifelse(is.nan(num/denom),
           0, num/denom)
  }
  # temp2[a(X,Z)] = E[I(X>C)temp(x_a,C,Y,Z)| X,Y,Z]
  temp2 = function(x_a, x, y){
    c_grid = seq(-1, 1, length = 20)
    dens = dtruncnorm(c_grid,  
                      a = -1, 
                      b = 1, 
                      mean = sum(c(1,y) * alpha2_star),
                      sd = tau2)
    dens = dens / sum(dens)
    sapply(c_grid, function(c_norm){
      (x > c_norm) * temp(x_a, c_norm, y)}) %*% dens
  }
  # temp3[a(X,Z)] = E[temp2(X,Y,Z)| X,Z]
  temp3 = function(x_a, x){
    sapply(sigma * cc$x + sum(beta * c(1,x)), function(y_norm){
      temp2(x_a, x, y_norm)}) %*% cc$w
  }
  temp3 = Vectorize(temp3, vectorize.args = 'x')
  # temp4 = E[I(X<C) | Y,X,Z]a(X,Z)
  temp4 = function(x, y){
    c_grid = seq(-1, 1, length = 20)
    dens = dtruncnorm(c_grid,
                      a = -1,
                      b = 1,
                      mean = sum(c(1,y) * alpha2_star),
                      sd = tau2)
    dens = dens / sum(dens)
    sum((x <= c_grid) * dens)
    # 1-ptruncnorm(x,
    #              a = -1,
    #              b = 1,
    #              mean = sum(c(1,y) * alpha2_star),
    #              sd = tau2)
  }
  temp4 = Vectorize(temp4, vectorize.args = 'y')
  # temp5 = E[temp4(X,Y,Z) | X,Z]a(X,Z)
  temp5 = function(x){
    sum(temp4(x, sigma * cc$x + sum(beta * c(1,x))) * cc$w)
  }
  temp5 = Vectorize(temp5, vectorize.args = 'x')
  res = diag(temp5(x_a)) + t(temp3(x_a, x_a))
  res
}  

```


```{r}
# Solution of integral equation
a_gauss_unif1_param2 = function(beta, x_a,
                                alpha2_star,
                                sigma = 4, tau2 = 1,
                                tt = 20){
  MASS::ginv(L_xz_gauss_unif1_param2(beta, x_a,
                                     alpha2_star,
                                     sigma, tau2,
                                     tt)) %*%
    t(b_xz_gauss_unif1_param2(beta, x_a,
                              alpha2_star,
                              sigma, tau2,
                              tt))
}
```

```{r}
S_eff_gauss_unif1_param2 = function(beta, y, w, delta,
                                    x_a, a0,
                                    sigma = 4, tau2 = 1,
                                    tt = 20){
  len_beta = length(beta)
  if(delta==0){
    #temp[a(X,Z)] =  E[I(X>C)a(X,Z)|C,Y,Z] / E[I(X>C)|C,Y,Z]
    temp = function(x_a, c, y){
      v_x = 1/(beta[2]^2 / sigma^2)
      eta_x = v_x * (beta[2] * (y - beta[1]) / sigma^2)
      # p: discretization of f(x|y,z) on x_a
      p = dtruncnorm(x_a,  
                     a = -1, 
                     b = 1, 
                     mean = eta_x,
                     sd = sqrt(v_x))
      num = (x_a > c) * p
      denom = sum(num)
      ifelse(is.nan(num/denom),
             0, num/denom)
    }
    #S_beta
    # sbeta = S_beta(beta, y, w, 0, z, alpha1_star, sigma, tau1)
    sbeta = S_beta_unif1(beta, y, w, 0, sigma)
    #S_eff = S_beta - a0
    return(sbeta - t(a0) %*% temp(x_a, w, y))
  } else{ # If delta=1, linearize from the grid
    m = length(x_a)
    a0_w = vector(length = len_beta)
    for(j in 1:len_beta){
      a0_w[j] = approx(x_a, a0[,j], w, rule = 2)$y #linear interpolation
    }
    sbeta = S_beta_f(beta, y, w, sigma)
    #S_eff = S_beta - a0
    return(sbeta - a0_w)
  }
}
```




```{r}
pe_gauss_unif1_param2 = function(beta, y_data, w_data, delta_data,
                                 x_a,
                                 alpha2_star,
                                 sigma = 4, tau1 = 1, tau2 = 1,
                                 tt = 20){
  len_beta = length(beta)
  # Define a0
  a0 = a_gauss_unif1_param2(beta, x_a,
                            alpha2_star,
                            sigma, tau2, tt)
  val = rep(0, len_beta)
  n = length(y_data)
  for(i in 1:n){
    val = val + S_eff_gauss_unif1_param2(beta, y_data[i], w_data[i], delta_data[i],
                                         x_a, a0,
                                         sigma, tau2, tt)
  }
  return(val)
}
```





```{r}
find_alpha1_MLE = function(beta, y_data, w_data, delta_data,
                           sigma = 4, tau1 = 1){
  log_llhd = function(alpha1_star, y, w, delta){
    v_x = 1/(beta[2]^2 / sigma^2 + 1/tau1^2)
    eta_x = v_x * (beta[2] * (y - beta[1]) / sigma^2
                   + alpha1_star / tau1^2)
    if(delta == 1){ #log(eta1(w|z))
      return(log(dtruncnorm(w,  
                            a = -1, 
                            b = 1, 
                            mean = eta_x,
                            sd = sqrt(v_x))))
    }else{ #log(P(X > w|y,z) * f(y|z))
      v_x = 1/(beta[2]^2 / sigma^2 + 1/tau1^2)
      eta_x = v_x * (beta[2] * (y - beta[1]) / sigma^2
                     + alpha1_star / tau1^2)
      # Y|Z ~ N(beta_0 + beta_1 E(X|Z) + beta_2^T Z, 1 + beta_1^2)
      return(log(pnorm(1, 
                       mean = eta_x,
                       sd = sqrt(v_x)) 
                 - pnorm(w,
                         mean = eta_x,
                         sd = sqrt(v_x))) +
               dnorm(y,
                     mean = sum(c(1, alpha1_star) * beta),
                     sd = sqrt(sigma^2 + beta[2]^2 * tau1^2), 
                     log = T) - 
               log(pnorm(1,
                         mean = alpha1_star,
                         sd = tau1) -
                     pnorm(-1,
                           mean = alpha1_star,
                           sd = tau1))
      ) 
    }
  }
  log_llhd_sum = function(alpha1){
    n = length(y_data)
    llhd = 0
    for(i in 1:n){
      llhd = llhd +
        log_llhd(alpha1, y_data[i], w_data[i], delta_data[i])
    }
    return(-llhd)
  }
  optimize(log_llhd_sum, interval = c(-5,5))$minimum
}
# # More values
# alpha1_MLE = NULL
# for(k in 1:1000){
#   data_k = data_generating(k, n, d, beta, alpha1, alpha2)
#   y_data = data_k$y_data
#   c_data = data_k$c_data
#   w_data = data_k$w_data
#   delta_data = data_k$delta_data
#   alpha1_MLE = cbind(alpha1_MLE,
#                      find_alpha1_MLE(beta, y_data, w_data, delta_data))
#   if(k %% 100 == 0){
#     print(k)
#   }
# }
# hist(alpha1_MLE[1,])
```


```{r}
# Find MLE of alpha2
find_alpha2_MLE = function(y_data, w_data, delta_data,
                           sigma = 4, tau2 = 1){
  log_llhd = function(alpha2_star, y, w, delta){
    if(delta == 1){ #log(P(C > w | y,z))
      return(log(1-ptruncnorm(w, 
                              a = -1,
                              b = 1,
                              mean = sum(c(1, y) * alpha2_star), 
                              sd = tau2)))
    }else{ #log(eta2(w|y,z))
      # Y|Z ~ N(beta_0 + beta_1 E(X|Z) + beta_2^T Z, 1 + beta_1^2)
      return(log(dtruncnorm(w, 
                            a = -1,
                            b = 1,
                            mean = sum(c(1, y) * alpha2_star), 
                            sd = tau2)))
    }
  }
  log_llhd_sum = function(alpha2){
    n = length(y_data)
    llhd = 0
    for(i in 1:n){
      llhd = llhd + log_llhd(alpha2, y_data[i], w_data[i], delta_data[i])
    }
    return(-llhd)
  }
  optim(rep(0,d+1), log_llhd_sum)$par
}
# # More values
# alpha2_MLE = NULL
# for(k in 1:1000){
#   data_k = data_generating(k, n, d, beta, alpha1, alpha2)
#   y_data = data_k$y_data
#   c_data = data_k$c_data
#   w_data = data_k$w_data
#   delta_data = data_k$delta_data
#   alpha2_MLE = cbind(alpha2_MLE,
#                      find_alpha2_MLE(y_data, w_data, delta_data))
#   if(k %% 100 == 0){
#     print(k)
#   }
# }
# hist(alpha2_MLE[1,])
```




```{r}
get_beta_param_unif1_param2 = function(k, n, d, 
                                       beta, alpha1, alpha2,
                                       sigma = 4, tau1 = 1, tau2 = 1, tt = 20, m = 20){
  data_k = data_generating(k, n, d, beta, alpha1, alpha2, sigma, tau1, tau2)
  y_data = data_k$y_data
  w_data = data_k$w_data
  delta_data = data_k$delta_data
  
  alpha2_MLE = find_alpha2_MLE(y_data, w_data, delta_data, sigma, tau2)
  x_a = seq(-1, 1, length.out = m)
  #equation solve
  tic(k)
  set.seed(k)
  result = nleqslv::nleqslv(beta + rnorm(d+1) * 0.1, pe_gauss_unif1_param2, 
                            y_data = y_data,
                            w_data = w_data,
                            delta_data = delta_data,
                            x_a=x_a,
                            alpha2_star = alpha2_MLE,
                            sigma = sigma,
                            tau1 = tau1,
                            tau2 = tau2,
                            tt = tt)
  toc()
  print(result$message)
  return(result$x)
}
# get_beta_param_unif1_param2(1, n, d,
#                        beta, alpha1, alpha2,
#                        sigma = 4, tau1 = 1, tau2 = 1, tt = 20, m = 20)
```


```{r, eval = F}
myCluster <- makeCluster(detectCores()-1)
registerDoSNOW(myCluster)
M = 1000
progress = function(n) cat(sprintf("task %d is complete\n", n))
opts = list(progress=progress)
clusterExport(myCluster, list('beta',
                              'alpha1',
                              'S_beta_f',
                              'S_beta',
                              'b_xz_gauss_unif1_param2',
                              'L_xz_gauss_unif1_param2',
                              'a_gauss_unif1_param2',
                              'S_eff_gauss_unif1_param2',
                              'pe_gauss_unif1_param2',
                              'data_generating',
                              'get_beta_param_unif1_param2'))
result_beta = foreach(k = 1:1000,
                      .combine = 'cbind',
                      .packages = c('MASS',
                                    'foreach',
                                    'doParallel',
                                    'gaussquad',
                                    'nleqslv',
                                    'pracma',
                                    'tictoc',
                                    'truncnorm'),
                      .options.snow=opts,
                      .verbose = T)%dopar%
  {
    set.seed(k)
    get_beta_param_unif1_param2(k, n, d,
                                beta, alpha1, alpha2 = c(3, 0.12),
                                sigma = 4, tau1 = 1, tau2 = 1, tt = 20, m = 20)
  }

save(result_beta, file = 'Case_unif1_param2_low.Rdata')

result_beta = foreach(k = 1:1000,
                      .combine = 'cbind',
                      .packages = c('MASS',
                                    'foreach',
                                    'doParallel',
                                    'gaussquad',
                                    'nleqslv',
                                    'pracma',
                                    'tictoc',
                                    'truncnorm'),
                      .options.snow=opts,
                      .verbose = T)%dopar%
  {
    set.seed(k)
    get_beta_param_unif1_param2(k, n, d,
                                beta, alpha1, alpha2 = c(1, 0.12),
                                sigma = 4, tau1 = 1, tau2 = 1, tt = 20, m = 20)
  }

save(result_beta, file = 'Case_unif1_param2_mid.Rdata')

result_beta = foreach(k = 1:1000,
                      .combine = 'cbind',
                      .packages = c('MASS',
                                    'foreach',
                                    'doParallel',
                                    'gaussquad',
                                    'nleqslv',
                                    'pracma',
                                    'tictoc',
                                    'truncnorm'),
                      .options.snow=opts,
                      .verbose = T)%dopar%
  {
    set.seed(k)
    get_beta_param_unif1_param2(k, n, d,
                                beta, alpha1, alpha2 = c(-1, 0.12),
                                sigma = 4, tau1 = 1, tau2 = 1, tt = 20, m = 20)
  }

save(result_beta, file = 'Case_unif1_param2_high.Rdata')
stopCluster(myCluster)
```




######################################3
# Variance estimation
```{r}
estimated_variance_unif1_param2 = function(beta, y_data, w_data, delta_data,
                                           sigma = 4, tau1 = 1, tau2 = 1, tt = 20, m = 20,
                                           eps = 0.001){
  len_beta = length(beta)
  alpha1_MLE = find_alpha1_MLE(beta, y_data, w_data, delta_data,
                               sigma, tau1)
  alpha2_MLE = find_alpha2_MLE(y_data, w_data, delta_data,
                               sigma, tau2)
  get_Seff_unif = function(beta, y_data, w_data, delta_data,
                       alpha2_star,
                       sigma, tau1, tau2,
                       tt, m, eps){
    # Define x_a
    x_a = seq(-1, 1, length.out = m)
    n = length(y_data)
    Seff = matrix(nrow = n, ncol = len_beta)
    #Define a0
    a0 = a_gauss_unif1_param2(beta, x_a,
                              alpha2_star,
                              sigma, tau2,
                              tt)
    for(i in 1:n){
      Seff[i,] = S_eff_gauss_unif1_param2(beta, y_data[i], w_data[i], delta_data[i],
                                   x_a, a0,
                                   sigma, tau2, tt)
    }
    return(Seff)
  }
  Seff_unif = get_Seff_unif(beta, y_data, w_data, delta_data,
                      alpha2_MLE,
                      sigma, tau1, tau2,
                      tt, m, eps)
  
  # Find Sbeta
  get_Sbeta = function(beta, y_data, w_data, delta_data,
                       sigma, tau1, tau2){
    n = length(y_data)
    Sbeta = matrix(nrow = n, ncol = len_beta)
    for(i in 1:n){
      Sbeta[i,] = S_beta(beta, y_data[i], w_data[i], delta_data[i],
                         alpha1_MLE, sigma, tau1)
      
    }
    return(Sbeta)
  }
  Sbeta = get_Sbeta(beta, y_data, w_data, delta_data,
                    sigma, tau1, tau2)
  # Find S2
  get_S2 = function(y_data, w_data, delta_data,
                    tau2, eps){
    log_llhd = function(alpha2_star, y, w, delta){
      if(delta == 1){ #log(P(C > w | y,z))
        return(log(1-ptruncnorm(w, 
                                a = -1,
                                b = 1,
                                mean = sum(c(1, y) * alpha2_star), 
                                sd = tau2)))
      }else{ #log(eta2(w|y,z))
        # Y|Z ~ N(beta_0 + beta_1 E(X|Z) + beta_2^T Z, 1 + beta_1^2)
        return(log(dtruncnorm(w, 
                              a = -1,
                              b = 1,
                              mean = sum(c(1, y) * alpha2_star), 
                              sd = tau2)))
      }
    }
    S2 = function(alpha2, y, w, delta){
      vec = vector(length = d+1)
      for(j in 1:(d+1)){
        dir = rep(0,d+1)
        dir[j] = 1
        vec[j] = (log_llhd(alpha2 + eps * dir, y, w, delta) 
                  - log_llhd(alpha2 - eps* dir, y, w, delta))  / (2*eps)
      }
      return(vec)
    }
    S2_val = matrix(nrow = n, ncol = d+1)
    for(i in 1:n){
      S2_val[i,] = S2(alpha2_MLE, y_data[i], w_data[i], delta_data[i])
    }
    return(S2_val)
  }
  S2 = get_S2(y_data, w_data, delta_data,
              tau2, eps)
  # Find phi2
  get_phi2 = function(S2){
    I2 = var(S2)
    phi2 = S2 %*% MASS::ginv(I2)
    return(phi2)
  }
  phi2 = get_phi2(S2)
  # Find matrices
  A2 =  - cov(Seff_unif, S2)
  B = - cov(Seff_unif, Sbeta)
  # Find Sigma2
  Sigma2 = var(Seff_unif + phi2 %*% t(A2))
  B_inv = MASS::ginv(B)
  return(B_inv %*% Sigma2 %*% t(B_inv))
}

```

```{r, eval = F}
myCluster <- makeCluster(detectCores()-1)
registerDoSNOW(myCluster)
M = 1000
progress = function(n) cat(sprintf("task %d is complete\n", n))
opts = list(progress=progress)
clusterExport(myCluster, list('beta',
                              'alpha1',
                              'S_beta_f',
                              'S_beta',
                              'b_xz_gauss_unif1_param2',
                              'L_xz_gauss_unif1_param2',
                              'a_gauss_unif1_param2',
                              'S_eff_gauss_unif1_param2',
                              'pe_gauss_unif1_param2',
                              'data_generating',
                              'get_beta_param_unif1_param2',
                              'estimated_variance_unif1_param2'))
load('Case_unif1_param2_low.Rdata')
variance = foreach(k = 1:1000,
                   .combine = 'cbind',
                   .packages = c('MASS',
                                 'foreach',
                                 'doParallel',
                                 'gaussquad',
                                 'nleqslv',
                                 'pracma',
                                 'tictoc',
                                 'truncnorm'),
                   .options.snow=opts,
                   .verbose = T)%dopar% 
  { 
    tic(k)
    beta_hat = result_beta[,k]
    data_k = data_generating(k, n, d, beta, alpha1, alpha2 = c(3, 0.12), sigma, tau1, tau2)
    y_data = data_k$y_data
    w_data = data_k$w_data
    delta_data = data_k$delta_data
    var_k = diag(estimated_variance_unif1_param2(
      beta_hat, y_data, w_data, delta_data,
      sigma = 4, tau1 = 1, tau2 = 1, tt = 20, m = 20,
      eps = 0.001))
    toc()
    c(k, var_k) 
  }
save(variance, file = 'Variance_unif1_param2_low.Rdata')


load('Case_unif1_param2_mid.Rdata')
variance = foreach(k = 1:1000,
                   .combine = 'cbind',
                   .packages = c('MASS',
                                 'foreach',
                                 'doParallel',
                                 'gaussquad',
                                 'nleqslv',
                                 'pracma',
                                 'tictoc',
                                 'truncnorm'),
                   .options.snow=opts,
                   .verbose = T)%dopar% 
  { 
    tic(k)
    beta_hat = result_beta[,k]
    data_k = data_generating(k, n, d, beta, alpha1, alpha2 = c(1, 0.12), sigma, tau1, tau2)
    y_data = data_k$y_data
    w_data = data_k$w_data
    delta_data = data_k$delta_data
    var_k = diag(estimated_variance_unif1_param2(
      beta_hat, y_data, w_data, delta_data,
      sigma = 4, tau1 = 1, tau2 = 1, tt = 20, m = 20,
      eps = 0.001))
    toc()
    c(k, var_k) 
  }
save(variance, file = 'Variance_unif1_param2_mid.Rdata')


load('Case_unif1_param2_high.Rdata')
variance = foreach(k = 1:1000,
                   .combine = 'cbind',
                   .packages = c('MASS',
                                 'foreach',
                                 'doParallel',
                                 'gaussquad',
                                 'nleqslv',
                                 'pracma',
                                 'tictoc',
                                 'truncnorm'),
                   .options.snow=opts,
                   .verbose = T)%dopar% 
  { 
    tic(k)
    beta_hat = result_beta[,k]
    data_k = data_generating(k, n, d, beta, alpha1, alpha2 = c(-1, 0.12), sigma, tau1, tau2)
    y_data = data_k$y_data
    w_data = data_k$w_data
    delta_data = data_k$delta_data
    var_k = diag(estimated_variance_unif1_param2(
      beta_hat, y_data, w_data, delta_data,
      sigma = 4, tau1 = 1, tau2 = 1, tt = 20, m = 20,
      eps = 0.001))
    toc()
    c(k, var_k) 
  }
save(variance, file = 'Variance_unif1_param2_high.Rdata')

stopCluster(myCluster)
```